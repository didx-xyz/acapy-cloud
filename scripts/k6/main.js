// Auto-generated by the postman-to-k6 converter
import http from 'k6/http';
import { check } from 'k6';
import { SharedArray } from 'k6/data';
import { getBearerToken } from './auth.js';
import { Trend, Counter } from 'k6/metrics';
import {
  createTenant,
  getWalletIdByWalletName,
  getAccessTokenByWalletId,
  deleteTenant,
  createIssuerTenant,
  createInvitation,
  acceptInvitation,
  createCredential,
  acceptCredential,
  createCredentialDefinition,
  getCredentialIdByThreadId,
  waitForSSEEvent,
  waitForSSEEventConnection
} from './tenant.js';

export let options = {
  vus: 2, // number of VUs to run
  iterations: 10, // total number of iterations (global)
  maxRedirects: 4,
  thresholds: { //https://community.grafana.com/t/ignore-http-calls-made-in-setup-or-teardown-in-results/97260/2
    'http_req_duration{scenario:default}': [`max>=0`],
    'http_reqs{scenario:default}': ['count >= 0'],
    'iteration_duration{scenario:default}': ['max>=0'],
    'specific_function_reqs{my_custom_tag:specific_function}': ['count>=0'],
    'specific_function_reqs{scenario:default}': ['count>=0'],
  },
};

const specificFunctionReqs = new Counter('specific_function_reqs');
const mainIterationDuration = new Trend('main_iteration_duration');

// Seed data: Generating a list of options.iterations unique wallet names
const wallets = new SharedArray('wallets', function() {
  const walletsArray = [];
  for (let i = 0; i < options.iterations; i++) {
    walletsArray.push({
      wallet_label: `k6 holder ${i}`,
      wallet_name: `k6_wallet_${i}`
    });
  }
  return walletsArray;
});

const numIssuers = 1;
let issuers = [];

// export function setup() {
//   const bearerToken = getBearerToken();
//   const issuers = []; // Initialize the issuers array
//   const numIssuers = 10; // Set your desired number of issuers

//   for (let i = 0; i < numIssuers; i++) {
//     const walletName = `xk6issuer_${i}`;
//     const existingWalletId = getWalletIdByWalletName(bearerToken, walletName);
//     if (existingWalletId) {
//       console.log(`Issuer ${walletName} already exists. Skipping creation.`);
//       // If the issuer already exists, populate the array with existing details
//       const accesToken = getAccessTokenByWalletId(bearerToken, existingWalletId);
//       issuers.push({
//         walletId: existingWalletId,
//         accessToken: accesToken,
//         credentialDefinitionId: "existingCredentialDefinitionId" // Replace this with the method to get the existing credential definition ID if available
//       });
//     } else {
//       const createIssuerTenantResponse = createIssuerTenant(bearerToken, walletName);
//       check(createIssuerTenantResponse, {
//         "Issuer tenant created successfully": (r) => r.status === 200
//       });

//       if (createIssuerTenantResponse.status === 200) {
//         const issuerResponseData = JSON.parse(createIssuerTenantResponse.body);
//         const issuerWalletId = issuerResponseData.wallet_id;
//         const issuerAccessToken = issuerResponseData.access_token;

//         const createCredentialDefinitionResponse = createCredentialDefinition(bearerToken, issuerAccessToken);
//         check(createCredentialDefinitionResponse, {
//           "Credential definition created successfully": (r) => r.status === 200
//         });

//         if (createCredentialDefinitionResponse.status === 200) {
//           const credentialDefinitionResponse = JSON.parse(createCredentialDefinitionResponse.body);
//           const credentialDefinitionId = credentialDefinitionResponse.id;
//           console.log(`Credential definition created successfully for issuer ${i}`);

//           issuers.push({
//             walletId: issuerWalletId,
//             accessToken: issuerAccessToken,
//             credentialDefinitionId: credentialDefinitionId
//           });
//         } else {
//           console.error(`Failed to create credential definition for issuer ${i}. Status: ${createCredentialDefinitionResponse.status}. Body: ${createCredentialDefinitionResponse.body}`);
//         }
//       } else {
//         console.error(`Failed to create issuer tenant for index ${i}. Status: ${createIssuerTenantResponse.status}.`);
//       }
//     }
//   }

//   if (issuers.length === 0) {
//     throw new Error("No issuer tenants were created successfully.");
//   }

//   console.log(`Created or verified ${issuers.length} issuer tenant(s) successfully.`);
//   return { bearerToken, issuers };
// }

export function setup() {
  const bearerToken = getBearerToken();
  for (let i = 0; i < numIssuers; i++) {
    const walletName = `xk6issuer_${i}`;
    const createIssuerTenantResponse = createIssuerTenant(bearerToken, walletName);
    check(createIssuerTenantResponse, {
      "Issuer tenant created successfully": (r) => r.status === 200
    });
    if (createIssuerTenantResponse.status === 200) {
      const issuerResponseData = JSON.parse(createIssuerTenantResponse.body);
      const issuerWalletId = issuerResponseData.wallet_id;
      const issuerAccessToken = issuerResponseData.access_token;

      const createCredentialDefinitionResponse = createCredentialDefinition(bearerToken, issuerAccessToken);
      check(createCredentialDefinitionResponse, {
        "Credential definition created successfully": (r) => r.status === 200
      });
      if (createCredentialDefinitionResponse.status === 200) {
        const credentialDefinitionResponse = JSON.parse(createCredentialDefinitionResponse.body);
        const credentialDefinitionId = credentialDefinitionResponse.id;
        console.log(`Credential definition created successfully for issuer ${i}`);

        issuers.push({
          walletId: issuerWalletId,
          accessToken: issuerAccessToken,
          credentialDefinitionId: credentialDefinitionId
        });
      } else {
        console.error(`Failed to create credential definition for issuer ${i}. Status: ${createCredentialDefinitionResponse.status}. Body: ${createCredentialDefinitionResponse.body}`);
      }
    } else {
      console.error(`Failed to create issuer tenant for index ${i}. Status: ${createIssuerTenantResponse.status}.`);
    }
  }
  if (issuers.length === 0) {
    throw new Error("No issuer tenants were created successfully.");
  }
  console.log(`Created ${issuers.length} issuer tenant(s) successfully.`);
  return { bearerToken, issuers };
}

// Helper function to calculate the wallet index based on VU and iteration
function getWalletIndex(vu, iter) {
  const iterationsPerVU = Math.floor(options.iterations / options.vus);
  const startIndex = (vu - 1) * iterationsPerVU;
  return startIndex + (iter % iterationsPerVU);
}

export default function(data) {
  const start = Date.now();
  const bearerToken = data.bearerToken;
  const issuers = data.issuers;
  // const walletIndex = ((__VU - 1) * (options.iterations/options.vus)) + __ITER;
  // const wallet = wallets[walletIndex];
  // VU10, ITER50: ((10-1) * (100/10)) + 50 = 50
  // VU1. ITER50: ((1-1) * (100/10)) + 50 = 50

  const walletIndex = getWalletIndex(__VU, __ITER);
  const wallet = wallets[walletIndex];

  const createTenantResponse = createTenant(bearerToken, wallet);
  check(createTenantResponse, {
    "Create Tenant Response status code is 200": (r) => {
      if (r.status !== 200) {
        throw new Error(`Unexpected response status: ${r.status}`);
      }
      return true;
    }
  });

  // Extract and set variables from the response
  const responseData = JSON.parse(createTenantResponse.body);
  const walletId = responseData.wallet_id;
  const holderAccessToken = responseData.access_token;

  // const tempAccessToken = getAccessTokenByWalletId(bearerToken, walletId);
  // console.log(`Access token for wallet ${walletId}: ${tempAccessToken}`);
  console.log(`Access token for wallet ${walletId}: ${holderAccessToken}`);

  const issuerIndex = __ITER % numIssuers;
  const issuer = issuers[issuerIndex];

  const createInvitationResponse = createInvitation(bearerToken, issuer.accessToken);
  check(createInvitationResponse, {
    "Invitation created successfully": (r) => {
      if (r.status !== 200) {
        throw new Error(`Unexpected response status while create invitation: ${r.status}`);
      }
      return true;
    }
  });

  const invitationResponseData = JSON.parse(createInvitationResponse.body);
  const invitationObj = invitationResponseData.invitation;
  const issuerConnectionId = invitationResponseData.connection_id;

  const acceptInvitationResponse = acceptInvitation(holderAccessToken, invitationObj);
  check(acceptInvitationResponse, {
    "Invitation accepted successfully": (r) => {
      if (r.status !== 200) {
        throw new Error(`Unexpected response while accepting invitation: ${r.response}`);
      }
      return true;
    }
  });

  const acceptInvitationResponseData = JSON.parse(acceptInvitationResponse.body);
  const holderInvitationConnectionId = acceptInvitationResponseData.connection_id;

  const waitForSSEEventConnectionResponse = waitForSSEEventConnection(holderAccessToken, walletId, holderInvitationConnectionId);
  check(waitForSSEEventConnectionResponse, {
    'SSE Event received successfully: connection-ready': (r) => {
      if (!r) {
        throw new Error('SSE event was not received successfully');
      }
      return true;
    },
  });

  const createCredentialResponse = createCredential(bearerToken, issuer.accessToken, issuer.credentialDefinitionId, issuerConnectionId);
  check(createCredentialResponse, {
    "Credential created successfully": (r) => {
      if (r.status !== 200) {
        throw new Error(`Unexpected response while creating credential: ${r.response}`);
      }
      return true;
    }
  });

  const createCredentialResponseData = JSON.parse(createCredentialResponse.body);
  const threadId = createCredentialResponseData.thread_id;

  const waitForSSEEventResponse = waitForSSEEvent(holderAccessToken, walletId, threadId);
  check(waitForSSEEventResponse, {
    'SSE Event received successfully: offer-received': (r) => {
      if (!r) {
        throw new Error('SSE event was not received successfully');
      }
      return true;
    },
  });

  const credentialId = getCredentialIdByThreadId(holderAccessToken, threadId);

  const acceptCredentialResponse = acceptCredential(holderAccessToken, credentialId);
  check(acceptCredentialResponse, {
    "Credential accepted successfully": (r) => {
      if (r.status !== 200) {
        throw new Error(`Unexpected response while accepting credential: ${r.response}`);
      }
      return true;
    }
  });

  specificFunctionReqs.add(1, { my_custom_tag: 'specific_function' });

  const end = Date.now();
  const duration = end - start;
  console.log(`Duration for iteration ${__ITER}: ${duration} ms`); // Log duration
  mainIterationDuration.add(duration);
}

export function teardown(data) {
  const bearerToken = data.bearerToken;
  const issuers = data.issuers;

  for (const issuer of issuers) {
    const deleteIssuerResponse = deleteTenant(bearerToken, issuer.walletId);
    check(deleteIssuerResponse, {
      "Delete Issuer Tenant Response status code is 200": (r) => {
        if (r.status !== 200) {
          console.error(`Unexpected response status while deleting issuer tenant ${issuer.walletId}: ${r.status}`);
          return false;
        } else {
          console.log(`Deleted issuer tenant ${issuer.walletId} successfully.`);
          return true;
        }
      }
    });
  }
  // // Delete holder tenants
  for (const wallet of wallets) {
    const walletId =  getWalletIdByWalletName(bearerToken, wallet.wallet_name);
    const deleteHolderResponse = deleteTenant(bearerToken, walletId);
    check (deleteHolderResponse, {
      "Delete Holder Tenant Response status code is 200": (r) => {
        if (r.status !== 200) {
          console.error(`Unexpected response status while deleting holder tenant ${walletId}: ${r.status}`);
          return false;
        } else {
          console.log(`Deleted holder tenant ${walletId} successfully.`);
          return true;
        }
      }
    });
  }
}

// export function handleSummary(data) {
//   let specificFunctionReqCount = 0;
//   if (data.metrics.specific_function_reqs) {
//       specificFunctionReqCount = data.metrics.specific_function_reqs.count;
//   }

//   console.log(`Total requests for specific function: ${specificFunctionReqCount}`);

//   return {
//       stdout: JSON.stringify(data, null, 2),
//       'summary.json': JSON.stringify(data, null, 2),
//   };
// }