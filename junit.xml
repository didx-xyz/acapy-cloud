<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="1" failures="2" skipped="0" tests="4" time="32.024" timestamp="2021-11-17T13:29:47.419733" hostname="MacBook-Pro-van-Moritz.local"><testcase classname="tests.proof.test_proof" name="test_send_proof_request" time="25.468"><failure message="KeyError: 'v10'">alice_connection_id = 'f5c88d58-579e-44b1-b579-e413058c3563'
async_client_alice_module_scope = &lt;httpx.AsyncClient object at 0x10845d100&gt;

    @pytest.mark.asyncio
    async def test_send_proof_request(
        alice_connection_id: str,
        async_client_alice_module_scope: AsyncClient,
    ):
        response = await async_client_alice_module_scope.post(
            BASE_PATH + f"/send-request?connection_id={alice_connection_id}",
            data=json.dumps(proof_dict['proof_request']),
        )
    
        result = response.json()
&gt;       assert result["v10"] is None
E       KeyError: 'v10'

app/tests/proof/test_proof.py:162: KeyError</failure></testcase><testcase classname="tests.proof.test_proof" name="test_create_proof_request" time="0.011"><failure message="KeyError: 'v10'">async_client_alice_module_scope = &lt;httpx.AsyncClient object at 0x10845d100&gt;

    @pytest.mark.asyncio
    async def test_create_proof_request(
        async_client_alice_module_scope: AsyncClient,
    ):
        response = await async_client_alice_module_scope.post(
            BASE_PATH
            + "/create-request?connection_id={alice_connection_id}&amp;protocol_version=2",
            data=json.dumps(indy_proof_request.dict()),
        )
    
        result = response.json()
&gt;       assert result["v10"] is None
E       KeyError: 'v10'

app/tests/proof/test_proof.py:200: KeyError</failure></testcase><testcase classname="tests.proof.test_proof" name="test_accept_proof_request" time="0.001" /><testcase classname="tests.proof.test_proof" name="test_reject_proof_request" time="6.211"><error message="failed on setup with &quot;app.facades.trust_registry.TrustRegistryException: Did did:sov:DfhqAWFYb1Ef2AechqwYQ2 not registered in the trust registry&quot;">async_client_bob_module_scope = &lt;httpx.AsyncClient object at 0x10840f0a0&gt;
alice_connection_id = 'f5c88d58-579e-44b1-b579-e413058c3563'
schema_definition = {'schema_': {'attr_names': ['speed'], 'id': 'JJ4saz1kcJV5k6Tiim2LJA:2:test_schema:0.3', 'name': 'test_schema', 'seq_no': 1426, ...}, 'schema_id': 'JJ4saz1kcJV5k6Tiim2LJA:2:test_schema:0.3'}
bob_connection_id = 'c2113123-9db6-44aa-8835-38d2cbd32707'
async_client_alice_module_scope = &lt;httpx.AsyncClient object at 0x10845d100&gt;

    @pytest.fixture(scope="module")
    async def credential_exchange_id(
        async_client_bob_module_scope: AsyncClient,
        alice_connection_id: str,
        schema_definition: Dict[str, Any],
        bob_connection_id: str,
        async_client_alice_module_scope: AsyncClient,
    ):
        """this fixture produces the CRED_X_ID but if the test that produces the CRED_X_ID has already run
        then this fixture just returns it..."""
        credential = {
            "protocol_version": "v1",
            "connection_id": bob_connection_id,
            "schema_id": schema_definition["schema_id"],
            "attributes": {"speed": "average"},
        }
    
&gt;       response = await async_client_bob_module_scope.post(
            "/generic/issuer/credentials",
            data=json.dumps(credential),
        )

app/tests/proof/test_proof.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1746: in post
    return await self.request(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1425: in request
    response = await self.send(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1510: in send
    response = await self._send_handling_auth(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1545: in _send_handling_auth
    response = await self._send_handling_redirects(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1579: in _send_handling_redirects
    response = await self._send_single_request(request, timeout)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_client.py:1620: in _send_single_request
    ) = await transport.handle_async_request(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/httpx/_transports/asgi.py:157: in handle_async_request
    await self.app(scope, receive, send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/fastapi/applications.py:199: in __call__
    await super().__call__(scope, receive, send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/middleware/errors.py:181: in __call__
    raise exc from None
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/middleware/errors.py:159: in __call__
    await self.app(scope, receive, _send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/exceptions.py:82: in __call__
    raise exc from None
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/exceptions.py:71: in __call__
    await self.app(scope, receive, sender)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/routing.py:580: in __call__
    await route.handle(scope, receive, send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/routing.py:241: in handle
    await self.app(scope, receive, send)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/starlette/routing.py:52: in app
    response = await func(request)
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/fastapi/routing.py:214: in app
    raw_response = await run_endpoint_function(
../../.pyenv/versions/3.8.10/lib/python3.8/site-packages/fastapi/routing.py:149: in run_endpoint_function
    return await dependant.call(**values)
app/generic/issuer/issuer.py:131: in send_credential
    await assert_valid_issuer(f"did:sov:{public_did.result.did}", credential.schema_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

did = 'did:sov:DfhqAWFYb1Ef2AechqwYQ2'
schema_id = 'JJ4saz1kcJV5k6Tiim2LJA:2:test_schema:0.3'

    async def assert_valid_issuer(did: str, schema_id: str):
        """Assert that an actor with the specified did is registered as issuer.
    
        This method asserts that there is an actor registered in the trust registry
        with the specified did. It verifies whether this actor has the `issuer` role
        and will also make sure the specified schema_id is regsitred as a valid schema.
        Raises an exception if one of the assertions fail.
    
        NOTE: the dids in the registry are registered as fully qualified dids. This means
        when passing a did to this method it must also be fully qualified (e.g. `did:sov:xxxx`)
    
        Args:
            did (str): the did of the issuer in fully qualified format.
            schema_id (str): the schema_id of the credential being issued
    
        Raises:
            Exception: When the did is not registered, the actor doesn't have the issuer role
                or the schema is not registered in the registry.
        """
        actor = await actor_by_did(did)
    
        if not actor:
&gt;           raise TrustRegistryException(f"Did {did} not registered in the trust registry")
E           app.facades.trust_registry.TrustRegistryException: Did did:sov:DfhqAWFYb1Ef2AechqwYQ2 not registered in the trust registry

app/facades/trust_registry.py:57: TrustRegistryException</error></testcase></testsuite></testsuites>